"""
This module define Plan and AlfredObject class
"""
# TODO: Plan module low action yet implemeted

import json
import re
import torch
from sentence_transformers import SentenceTransformer
from sentence_transformers import util as st_utils
import numpy as np
from data.alfred_data import constants
import time

class Plan:
    """Generalize plan generated from traj_data, gpt response, and list of triplets"""
    NAV_ACTIONS = {'LookDown', 'LookUp', 'MoveAhead', 'RotateLeft', 'RotateRight'}
    HIGH_INTERACT_ACTIONS = \
        ['HeatObject', 'CoolObject', 'CleanObject', 'ToggleObject', 'SliceObject']
    HIGH_ACTIONS = ['PickupObject', 'PutObject', 'HeatObject', 'CleanObject', 'CleanObject', 'ToggleObject', 'SliceObject']
    def __init__(self, high_desc=None, low_desc=None, triplets=None, low_actions=None, refine=False, ignore_exception=False):
        # check triplet validity
        for action_idx, high_action in enumerate(triplets):
            if high_action[0] in Plan.HIGH_INTERACT_ACTIONS:
                # Error correcting: arg name different with in-hand obj
                if high_action[0] in Plan.HIGH_INTERACT_ACTIONS[:3] and high_action[1] != triplets[action_idx-1][1]:
                    high_action[1] = triplets[action_idx-1][1]

                if high_action[1] not in \
                    constants.VAL_ACTION_OBJECTS[
                        ['Heatable', 'Coolable', 'Cleanable', 'Toggleable', 'Sliceable'][Plan.HIGH_INTERACT_ACTIONS.index(high_action[0])]]:
                    if not ignore_exception:
                        raise Exception(f"{high_action[1]} is not {high_action[0]}-able.")
            if high_action[2] not in constants.RECEPTACLES | {'0', '', 'FloorLamp', 'DeskLamp'}:
                if not ignore_exception:
                    raise Exception(f'{high_action[2]} can\'t be in third pos')
            if high_action[0] == 'PutObject':
                # change (Put, recep, recep) to (Put, obj, recep)
                if high_action[1] in constants.RECEPTACLES and (high_action[1] == high_action[2] or high_action[2] == '0'):
                    if triplets[action_idx-1][0] == 'SliceObject':
                        new_action = ['PutObject', triplets[action_idx-2][1], high_action[1]]
                    else:
                        new_action = ['PutObject', triplets[action_idx-1][1], high_action[1]]
                    high_action = new_action
                triplets[action_idx] = high_action
            triplets[action_idx] = [high_action[0], high_action[1].split('Sliced')[0], high_action[2]]

        self.high_desc = high_desc
        self.low_desc = low_desc
        self.high_actions = triplets
        self.low_actions = low_actions
        if refine:
            self.refine_plan()

    @classmethod
    def get_available_actions(cls) -> dict:
        """Get Alfred executable actions"""
        return json.load(open('../data/available_actions1.json', 'r'))
    @classmethod
    def from_str(cls, str_plan:str, goal='', steps=''):
        """Generate Plan from String (ex. GPT response)"""
        def closest_object_roberta(key):
            corpus = list(available_tasks)
            available_action_list = [Plan.preprocess_goal(o) for o in corpus]
            device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
            translation_lm = SentenceTransformer('stsb-roberta-large').to(device)
            example_task_embedding = translation_lm.encode(
                available_action_list, batch_size=512, convert_to_tensor=True, device=device
                )
            query_embedding = translation_lm.encode(
                Plan.preprocess_goal(key), convert_to_tensor=True, device=device
                )
            cos_scores = st_utils.pytorch_cos_sim(
                query_embedding, example_task_embedding
                )[0].detach().cpu().numpy()
            idx = np.argsort(cos_scores)[-1]
            most_similar_object, matching_score = corpus[idx], cos_scores[idx]
            return most_similar_object, matching_score

        plan = str_plan.split('\n')
        action_seq = []; cos_score = []
        available_actions = Plan.get_available_actions()
        available_tasks = set(available_actions.keys())
        # match sugoal generated by GPT into ALFRED available subgoals
        for action in plan:
            # Remove empty string
            if action.strip() == '':
                continue
            if ':' in action and not any(temp.isdigit() for temp in action):
                break
            action = re.sub(r"[0-9]", "", action).strip('. ').lower()
            most_similar_task, score = closest_object_roberta(action.lower())
            action_seq.append(available_actions[most_similar_task])
            cos_score.append(float(score))
        # Remove repititive subgoals
        temp = []
        for i, action in enumerate(action_seq):
            if i != 0 and action == action_seq[i-1]:
                continue
            temp.append(action)
        action_seq = temp
        return Plan(high_desc=goal, low_desc=steps, triplets=action_seq), cos_score

    @classmethod
    def from_traj(cls, traj_data:dict, r_idx=None):
        """Generate Plan from trajectory data"""
        if 'ann' in traj_data:
            r_idx = traj_data['ann']['repeat_idx']
        alfred_obj_lower_to_id = dict(zip(constants.OBJECTS_SINGULAR ,constants.OBJECTS))

        triplets = []
        low_actions = []

        for action_chunk in traj_data['plan']['high_pddl']:
            if action_chunk['discrete_action']['action'] in ['GotoLocation', 'NoOp']:
                continue
            h_idx = action_chunk['high_idx']
            action = action_chunk['discrete_action']['action']

            target = action_chunk['planner_action']['coordinateObjectId'][0] \
                if 'coordinateObjectId' in action_chunk['planner_action'] else ''
            recep = action_chunk['planner_action']['coordinateReceptacleObjectId'][0] \
                if 'coordinateReceptacleObjectId' in action_chunk['planner_action'] else ''
            
            if target == '':
                if action_chunk['discrete_action']['args'][0] != '':
                    target = alfred_obj_lower_to_id[action_chunk['discrete_action']['args'][0]]
                else:
                    target = triplets[-1][1]
            if target == '':
                raise Exception('Target not determined')
                
            if recep == '':
                object_id = action_chunk['planner_action']['objectId']
                object_id = '|'.join(object_id.split('|')[:3])
                for _action_chunk in traj_data['plan']['high_pddl']:
                    if _action_chunk['planner_action']['action'] in cls.NAV_ACTIONS | set(['GotoLocation', 'End']):
                        continue
                    _id = '|'.join(_action_chunk['planner_action']['objectId'].split('|')[:4])
                    if _id == object_id\
                        and 'coordinateReceptacleObjectId' in _action_chunk['planner_action'] \
                            and _action_chunk['planner_action']['action'] == 'PickupObject':
                        recep = _action_chunk['planner_action']['coordinateReceptacleObjectId'][0]
                        if h_idx < _action_chunk['high_idx']:
                            break
            low_action = []
            for low_chunk in traj_data['plan']['low_actions']:
                if low_chunk['high_idx'] > h_idx:
                    break
                if low_chunk['high_idx'] < h_idx:
                    continue
                if low_chunk['api_action']['action'] in Plan.NAV_ACTIONS:
                    continue
                low_action.append((
                    low_chunk['api_action']['action'],
                    low_chunk['api_action']['objectId'].split('|')[0]))

            triplets.append([action, target, recep])
            low_actions.append(low_action)

        goal = traj_data['turk_annotations']['anns'][r_idx]['task_desc']
        steps = '\n'.join(traj_data['turk_annotations']['anns'][r_idx]['high_descs'])
        return Plan(high_desc=goal, low_desc=steps, triplets=triplets, low_actions=low_actions)

    @classmethod
    def preprocess_goal(cls, s):
        """Preprocess goal"""
        # remove escape sequence
        s = s.strip()
        if "\n" in s:
            s = s.split("\n")[0]
        if "\b" in s:
            s = s.strip("\b")
        s = s.strip()
        if not any(_s.isupper() for _s in s):
            # lower
            return s.lower()
        # CounterTop -> Counter Top
        capitals = re.findall('[A-Z][^A-Z]*', s)
        processed = []
        left = s.split(capitals[0])[0]
        for _l in capitals:
            if len(_l) == 1:
                left += _l
            else:
                _l = left+_l
                processed.extend(_l.split())
        if len(processed) == 0:
            processed = left.split()
        # lower
        return ' '.join(processed).lower().replace('.', '')
        
    def refine_plan(self):
        """
        Refill receptacle info in triplet refering high actions
        """
        triplets = self.high_actions
        for i, triplet in enumerate(triplets):
            if triplet[2] == '':
                if triplet[0] == 'SliceObject':
                    target_found = False
                    for k in triplets[i:]:
                        if k[0] == 'PickupObject' and k[1] == triplet[1] and k[2] != '':
                            triplet[2] = k[2]
                            target_found = True
                            break
                    if not target_found:
                        for k in triplets[i-1::-1]:
                            if k[0] == 'PutObject' and k[1] == triplet[1]:
                                triplet[2] = k[2]
                                target_found = True
                                break
            triplets[i] = triplet
        self.high_actions = triplets

    def get_final_state(self) -> list:
        """Return result alfred objs after executing plan"""
        in_hand = None
        seen_objs = []
        for action in self.high_actions:
            if action[0] == 'PickupObject':
                if in_hand is not None:
                    raise Exception(f"Error: [Pick up] command holding a/an {in_hand.name}")
                # If command Pickup obj in seen objs
                temp = seen_objs
                for _obj in seen_objs:
                    if _obj.name == action[1] \
                        and (_obj.recep == action[2] or (_obj.recep is None and action[2] == '')):
                        in_hand = _obj
                        temp.remove(_obj)
                seen_objs = temp
                # else
                if in_hand is None:
                    in_hand = AlfredObject(action[1])
                # picked up obj has no recep info now
                in_hand.put(None)
            elif action[0] == 'SliceObject':
                if 'knife' not in in_hand.name.lower():
                    raise Exception(f"Error: [Slice] command not holding a knife")
                obj = AlfredObject(action[1], recep=action[2])
                obj.slice()
                seen_objs.append(obj)
            elif action[0] == 'PutObject':
                if action[1] != in_hand.name:
                    raise Exception(f"Error: [Put] command requesting {action[1]} != {in_hand.name}")
                in_hand.put(action[2])
                seen_objs.append(in_hand)
                in_hand = None
            elif action[0] == 'ToggleObject':
                if in_hand is not None:
                    in_hand.examine()
            elif action[0] == 'HeatObject':
                if action[1] != in_hand.name and action[1] != "":
                    raise Exception(f"Error: [Heat] command requesting {action[1]} != {in_hand.name}")
                in_hand.heat()
            elif action[0] == 'CoolObject':
                if action[1] == in_hand.name:
                    in_hand.cool()
                elif any([o.recep == 'Fridge' for o in seen_objs]):
                    for _obj in seen_objs:
                        if _obj.recep == 'Fridge':
                            _obj.cool()
                else:
                    raise Exception('Cool object not specified')
            elif action[0] == 'CleanObject':
                if action[1] != in_hand.name and action[1] != "":
                    raise Exception(f"Error: [Clean] command requesting {action[1]} != {in_hand.name}")
                in_hand.wash()
            else:
                raise Exception('Action not defined')

        if in_hand is not None:
            seen_objs.append(in_hand)

        return seen_objs
    
    def get_ex_high(self):
        s_idx = len(self.high_actions)
        s_obj = ""
        ex_high_actions = []
        for t_idx, triplet in enumerate(self.high_actions):
            action, target, recep = triplet
            if s_idx < t_idx and s_obj == target:
                target = target+"Sliced"
            
            if action == 'SliceObject':
                s_idx = t_idx
                s_obj = target
            elif action == 'PutObject' and target == s_obj:
                s_idx = len(self.high_actions)
                s_obj = ""
            
            ex_high_actions.append([action, target, recep])
        return ex_high_actions

    def __eq__(self, other_plan):
        if not self.is_executable() or not other_plan.is_executable():
            raise Exception('One of given plans is not executable')

        objs1 = self.get_final_state()
        objs2 = other_plan.get_final_state()
        only_in_1 = objs1.copy()
        only_in_2 = objs2.copy()

        if any([o.sliced for o in objs1]):
            # If slice task, don't matter type of knife or where knife is
            if not any([o.sliced for o in objs2]):
                return False
            for obj1 in objs1:
                if 'knife' in obj1.name.lower():
                    only_in_1.remove(obj1)
                    for obj2 in objs2:
                        if 'knife' in obj2.name.lower():
                            only_in_2.remove(obj2)
                            break
                else:
                    for obj2 in objs2:
                        if obj1 == obj2:
                            only_in_1.remove(obj1)
                            only_in_2.remove(obj2)
        elif any([o.in_light for o in objs1]):
            if not any([o.in_light for o in objs2]):
                return False
            for obj1 in objs1:
                if 'lamp' in obj1.name.lower():
                    only_in_1.remove(obj1)
                    for obj2 in objs2:
                        if 'lamp' in obj2.name.lower():
                            only_in_2.remove(obj2)
                            break
                else:
                    for obj2 in objs2:
                        if obj1 == obj2:
                            only_in_1.remove(obj1)
                            only_in_2.remove(obj2)
        else:
            for obj_in_1 in objs1:
                for obj_in_2 in objs2:
                    if obj_in_1 == obj_in_2:
                        only_in_1.remove(obj_in_1)
                        only_in_2.remove(obj_in_2)
        return len(only_in_1) == 0 and len(only_in_2) == 0

    def __str__(self):
        desc = ""
        for i, action in enumerate(self.high_actions):
            desc += f"{i+1}. {action[0].replace('Object', ''):8s} {action[1]} {action[2]}\n"
        return desc

    def is_executable(self, verbose=False) -> bool:
        """Check if plan is executable"""
        try:
            self.get_final_state()
            return True
        except Exception as e:
            if verbose:
                print(e)
            return False

    def is_plan_fulfilled(self, task_type:str, params:dict) -> bool:
        """Check if the plan fulfilled task requirement"""
        if not self.is_executable():
            print(self.high_actions)
            raise Exception('This plan is not executable')
        seen_objs = self.get_final_state()
        mrecep, target = [], []
        for _obj in seen_objs:
            if _obj.name == params['mrecep_target']:
                mrecep.append(_obj)
            if _obj.name == params['object_target']:
                target.append(_obj)

        if params['object_sliced'] and not any([t.sliced for t in target]):
            return False
        if task_type == 'pick_and_place_simple'\
            and not any([t.recep == params['parent_target'] for t in target]):
            return False
        if task_type == 'pick_two_obj_and_place'\
            and not len([t.recep == params['parent_target'] for t in target]) > 1:
            return False
        if task_type == 'look_at_obj_in_light'\
            and not any([t.in_light for t in target]):
            return False
        if task_type == 'pick_clean_then_place_in_recep'\
            and not any([t.clean for t in target])\
                and not any([t.recep == params['parent_target'] for t in target]):
            return False
        if task_type == 'pick_heat_then_place_in_recep'\
            and not any([t.hot for t in target])\
                and not any([t.recep == params['parent_target'] for t in target]):
            return False
        if task_type == 'pick_cool_then_place_in_recep'\
            and not any([t.cold for t in target])\
                and not any([t.recep == params['parent_target'] for t in target]):
            return False
        if task_type == 'pick_and_place_with_movable_recep':
            if not any([m.recep == params['parent_target'] for m in mrecep])\
                or not any([t.recep == params['mrecep_target'] for t in target]):
                return False
        return True
    
    def get_low_actions(self):
        if self.low_actions is not None:
            return self.low_actions
        low_actions = []
        high_idxs = []
        
        s_idx = len(self.high_actions)
        s_obj = ""
        pre_opened = False
        for t_idx, triplet in enumerate(self.high_actions):
            action, target, recep = triplet
            if s_idx < t_idx and s_obj == target:
                target = target+"Sliced"
            
            if action == "SliceObject":
                s_idx = t_idx
                s_obj = target
            
            # transfer to low actions
            if action == "PutObject":
                # slice initialize
                if s_obj+'Sliced' == target:
                    s_idx = len(self.high_actions)
                # mrecep task recep yield
                if t_idx < len(self.high_actions)-1 and self.high_actions[t_idx+1][0] == "PickupObject" \
                    and self.high_actions[t_idx+1][1] == recep \
                        and self.high_actions[t_idx+1][2] in constants.OPENABLE_CLASS_SET-{'Box'}:
                    _low_actions = [
                        ["GotoLocation", self.high_actions[t_idx+1][2]],
                        ["OpenObject", self.high_actions[t_idx+1][2]],
                        ["PutObject", recep]
                    ]
                    pre_opened = True
                    
                elif recep in constants.OPENABLE_CLASS_SET-{'Box'}:
                    _low_actions = [
                        ["GotoLocation", recep],
                        ["OpenObject", recep],
                        ["PutObject", recep],
                        ["CloseObject", recep]
                    ]
                else:
                    _low_actions = [
                        ["GotoLocation", recep],
                        ["PutObject", recep],
                    ]
            elif action == "HeatObject":
                _low_actions = [
                    ["GotoLocation", "Microwave"],
                    ["OpenObject", "Microwave"],
                    ["PutObject", "Microwave"],
                    ["CloseObject", "Microwave"],
                    ["ToggleObjectOn", "Microwave"],
                    ["ToggleObjectOff", "Microwave"],
                    ["OpenObject", "Microwave"],
                    ["PickupObject", target]
                ]
            elif action == "CoolObject":
                _low_actions = [
                    ["GotoLocation", "Fridge"],
                    ["OpenObject", "Fridge"],
                    ["PutObject", "Fridge"],
                    ["CloseObject", "Fridge"],
                    ["OpenObject", "Fridge"],
                    ["PickupObject", target]
                ]
            elif action == "CleanObject":
                _low_actions = [
                    ["GotoLocation", "SinkBasin"],
                    ["PutObject", "SinkBasin"],
                    ["ToggleObjectOn", "Faucet"],
                    ["ToggleObjectOff", "Faucet"],
                    ["PickupObject", target]
                ]
            elif action == "ToggleObject":
                _low_actions = [
                    ["GotoLocation", target],
                    ["ToggleObjectOn", target]
                ]
            else:
                if recep in constants.OPENABLE_CLASS_SET-{'Box'}:
                    if pre_opened:
                        _low_actions = [
                            [action, target],
                            ["CloseObject", recep]
                        ]
                        pre_opened = False
                    else:
                        _low_actions = [
                            ["GotoLocation", recep],
                            ["OpenObject", recep],
                            [action, target],
                            ["CloseObject", recep]]
                else:
                    _low_actions = [
                        ["GotoLocation", target],
                        [action, target]
                    ]
            high_idxs.extend([t_idx]*len(_low_actions))
            low_actions.extend(_low_actions)
        self.low_actions = low_actions
        return high_idxs, low_actions

class AlfredObject:
    """Object in alfred saving status information"""
    receptacles = constants.RECEPTACLES
    val_recep_objects = constants.VAL_RECEPTACLE_OBJECTS
    val_action_objects = constants.VAL_ACTION_OBJECTS
    non_recep_objects = constants.NON_RECEPTACLES_SET

    def __init__(self, name, recep=None):
        self.sliced, self.clean, self.hot, self.cold, self.in_light \
            = False, False, False, False, False
        assert name in AlfredObject.non_recep_objects
        self.name = name
        assert recep in AlfredObject.receptacles or recep is None or recep == '' or recep == '0'
        if recep == '':
            self.recep = None
        else:
            self.recep = recep

    def __str__(self):
        desc = f"{self.name:10s}:\n"
        if self.sliced:
            desc += f" * {'sliced':8s}\n"
        if self.clean:
            desc += f" * {'clean':8s}\n"
        if self.hot:
            desc += f" * {'hot':8s}\n"
        if self.cold:
            desc += f" * {'cold':8s}\n"
        if self.in_light:
            desc += f" * {'in light':8s}\n"
        if self.recep is not None:
            desc += f"   in {self.recep:8s}"
        else:
            desc += f"   in hand"
        return desc

    def __eq__(self, other):
        if not isinstance(other, AlfredObject):
            return False
        return (self.name, self.recep, self.sliced, \
            self.clean, self.hot, self.cold, self.in_light)\
            == (other.name, other.recep, other.sliced, \
                other.clean, other.hot, other.cold, other.in_light)

    def wash(self):
        assert self.name in AlfredObject.val_action_objects['Cleanable']
        self.clean = True

    def heat(self):
        assert self.name in AlfredObject.val_action_objects['Heatable']
        self.hot = True

    def cool(self):
        assert self.name in AlfredObject.val_action_objects['Coolable']
        self.cold = True

    def examine(self):
        assert self.name in AlfredObject.non_recep_objects
        self.in_light = True

    def put(self, recep):
        assert recep in AlfredObject.receptacles or recep is None
        self.recep = recep

    def slice(self):
        assert self.name in AlfredObject.val_action_objects['Sliceable']
        self.sliced = True

import openai
import yaml
def set_openai_key():
    config = yaml.load(open('utils/config.yaml', 'r'), Loader=yaml.FullLoader)
    openai.api_key = config['openai']['api_key']
    openai.organization = config['openai']['organization']

def get_gpt_response(prompt, args):
    """ Get gpt3 response"""
    set_openai_key()
    while True:
        try:
            response = openai.Completion.create(
                model = 'text-davinci-003',
                prompt = prompt,
                temperature = args['temp'],
                logprobs=1,
                n = args['n'],
                max_tokens = args['max_tokens'],
                stop = args['stop'],
                presence_penalty = args['presence_penalty']
            )
            break
        except openai.error.ServiceUnavailableError:
            print('OpenAI server got too much traffic')
            time.sleep(0.3)
        except openai.error.RateLimitError:
            print('Reached Rate Limit')
            time.sleep(0.3)
        except openai.error.APIConnectionError:
            print('OPENAI API connection Error occured')
            time.sleep(0.3)
        except openai.error.APIError:
            print('API Error')
            time.sleep(1)
        except openai.error.InvalidRequestError as e:
            prompt_length = int(re.findall(r'\d+', e.user_message)[2])
            args['max_tokens'] = 4097-prompt_length
            print(f"Max token resized to {args['max_tokens']}")
        except Exception as e:
            print(prompt)
            raise e
    if response.usage['total_tokens'] >= args['max_tokens']*0.9:
        print('Warning: Used up to 90%'+' of max token')
    return response

def get_action_description(triplet_list:list) -> list:
    """triplets to subgoal descripitons"""
    prompts = []
    for triplet in triplet_list:
        if triplet[1] == 'Boots':
            triplet[1] == 'a pair of boots'
        if triplet[2] == 'Boots':
            triplet[2] == 'a pair of boots'
        if triplet[0] == 'PickupObject':
            if triplet[2] == '':
                sentence = 'Pick up a %s'%triplet[1]
            else:
                sentence = 'Pick up a %s from %s'%(triplet[1], triplet[2])
        elif triplet[0] == 'PutObject':
            assert all([a != '' for a in triplet])
            sentence = 'Put a %s on %s'%(triplet[1], triplet[2])
        elif triplet[0] == 'ToggleObject':
            sentence = 'Turn a %s on'%(triplet[1])
        elif triplet[0] == 'HeatObject':
            sentence = 'Heat a %s in hand'%(triplet[1])
        elif triplet[0] == 'CoolObject':
            sentence = 'Chill a %s in hand'%(triplet[1])
        elif triplet[0] == 'CleanObject':
            sentence = 'Wash a %s in hand'%(triplet[1])
        elif triplet[0] == 'SliceObject':
            if triplet[2] == '':
                sentence = 'Cut a %s'%(triplet[1])
            else:    
                sentence = 'Cut a %s on %s'%(triplet[1], triplet[2])
        
        prompt = "Correct this in standard English grammar: \n\n%s\n"%(sentence)
        prompts.append(prompt)
        
    # Grammer correction using gpt
    args = {"temp": 0, "n": 1, "max_tokens": 80, 'stop': None, 'presence_penalty': -1}
    response = get_gpt_response(prompts, args)
    results = [c.text.strip() for c in response.choices]
    remove_idx = []
    for idx, r in enumerate(response.choices):
        test_tokens = r['logprobs']['token_logprobs']
        test_tokens.sort()
        test_tokens = test_tokens[:int(0.1*len(test_tokens))+1]
        if sum(test_tokens)/len(test_tokens) < -0.50:
            print(f"{prompts[idx]} {r.text} is not favored")
            remove_idx.append(idx)
    if "" in results:
        raise Exception("Null response")
    return results, remove_idx

def get_confusion(self, task_type:str, params:dict) -> bool:
        """Check if the plan fulfilled task requirement"""
        if not self.is_executable():
            print(self.high_actions)
            raise Exception('This plan is not executable')
        seen_objs = self.get_final_state()
        for seen_obj in seen_objs:
            print(seen_obj.name, seen_obj.recep)
            print(seen_obj.sliced, seen_obj.clean, seen_obj.hot, seen_obj.cold, seen_obj.in_light)
        mrecep, target = [], []
        for _obj in seen_objs:
            if _obj.name == params['mrecep_target']:
                mrecep.append(_obj)
            if _obj.name == params['object_target']:
                target.append(_obj)

        confusion_list = {
            'object_target': [], # [[pred, GT], [pred, GT], ...]
            'mrecep_target': [], # [[pred, GT], [pred, GT], ...]
            'parent_target': [], # [[pred, GT], [pred, GT], ...]
        }
        for obj in seen_objs:
            if task_type in [
                'pick_and_place_simple',
                'pick_two_obj_and_place', 
                'pick_clean_then_place_in_recep',
                'pick_clean_then_place_in_recep',
                'pick_heat_then_place_in_recep',
                'pick_cool_then_place_in_recep',
            ]:
                if obj.name != params['object_target']:
                    confusion_list['object_target'].append([obj.name, params['object_target']])
                if obj.recep != params['parent_target']:
                    confusion_list['parent_target'].append([obj.recep, params['parent_target']])
            if task_type == 'look_at_obj_in_light':
                if obj.name != params['object_target']:
                    confusion_list['object_target'].append([obj.name, params['object_target']])
            if task_type == 'pick_and_place_with_movable_recep':
                # heuristic for object-mrecep-parent
                #assert len(seen_objs) == 2
                if len(seen_objs) == 2 and (seen_objs[0].recep == seen_objs[1].name or seen_objs[1].recep == seen_objs[0].name):
                    if seen_objs[0].recep == seen_objs[1].name:
                        object_target = seen_objs[0].name
                        mrecep_target = seen_objs[0].recep
                        parent_target = seen_objs[1].recep
                    elif seen_objs[1].recep == seen_objs[0].name:
                        object_target = seen_objs[1].name
                        mrecep_target = seen_objs[1].recep
                        parent_target = seen_objs[0].recep
                    if object_target != params['object_target']:
                        confusion_list['object_target'].append([object_target, params['object_target']])
                    if mrecep_target != params['object_target']:
                        confusion_list['mrecep_target'].append([mrecep_target, params['mrecep_target']])
                    if parent_target != params['parent_target']:
                        confusion_list['parent_target'].append([parent_target, params['parent_target']])
                
        return confusion_list