"""
This module define Plan and AlfredObject class
"""
# TODO: Plan module low action yet implemeted

import json
import re
import torch
from sentence_transformers import SentenceTransformer
from sentence_transformers import util as st_utils
import numpy as np
from data.alfred_data import constants

class Plan:
    """Generalize plan generated from traj_data, gpt response, and list of triplets"""
    NAV_ACTIONS = {'LookDown', 'LookUp', 'MoveAhead', 'RotateLeft', 'RotateRight'}
    HIGH_INTERACT_ACTIONS = \
        ['HeatObject', 'CoolObject', 'CleanObject', 'ToggleObject', 'SliceObject']
    HIGH_ACTIONS = ['PickupObject', 'PutObject', 'HeatObject', 'CleanObject', 'CleanObject', 'ToggleObject', 'SliceObject']
    def __init__(self, high_desc=None, low_desc=None, triplets=None, low_actions=None):
        # check triplet validity
        for action_idx, high_action in enumerate(triplets):
            if high_action[0] in Plan.HIGH_INTERACT_ACTIONS:
                # Error correcting: arg name different with in-hand obj
                if high_action[0] in Plan.HIGH_INTERACT_ACTIONS[:3] and high_action[1] != triplets[action_idx-1][1]:
                    high_action[1] = triplets[action_idx-1][1]

                if high_action[1] not in \
                    constants.VAL_ACTION_OBJECTS[
                        ['Heatable', 'Coolable', 'Cleanable', 'Toggleable', 'Sliceable'][Plan.HIGH_INTERACT_ACTIONS.index(high_action[0])]]:
                    raise Exception(f"{high_action[1]} is not {high_action[0]}-able.")
            assert high_action[2] in constants.RECEPTACLES | {'0', '', 'FloorLamp', 'DeskLamp'}
            if high_action[0] == 'PutObject':
                # change (Put, recep, recep) to (Put, obj, recep)
                if high_action[1] in constants.RECEPTACLES and (high_action[1] == high_action[2] or high_action[2] == '0'):
                    if triplets[action_idx-1][0] == 'SliceObject':
                        new_action = ['PutObject', triplets[action_idx-2][1], high_action[1]]
                    else:
                        new_action = ['PutObject', triplets[action_idx-1][1], high_action[1]]
                    # print(f'{high_action} -> {new_action}')
                    high_action = new_action
                triplets[action_idx] = high_action
            triplets[action_idx] = [high_action[0], high_action[1].split('Sliced')[0], high_action[2]]

        self.high_desc = high_desc
        self.low_desc = low_desc
        self.high_actions = triplets
        self.low_actions = low_actions
        self.refine_plan()

    @classmethod
    def get_available_actions(cls) -> dict:
        """Get Alfred executable actions"""
        return json.load(open('../data/available_actions.json', 'r'))
    @classmethod
    def from_str(cls, str_plan:str, goal='', steps=''):
        """Generate Plan from String (ex. GPT response)"""
        def closest_object_roberta(key):
            corpus = list(available_tasks)
            available_action_list = [Plan.preprocess_goal(o) for o in corpus]
            device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
            translation_lm = SentenceTransformer('stsb-roberta-large').to(device)
            example_task_embedding = translation_lm.encode(
                available_action_list, batch_size=512, convert_to_tensor=True, device=device
                )
            query_embedding = translation_lm.encode(
                Plan.preprocess_goal(key), convert_to_tensor=True, device=device
                )
            cos_scores = st_utils.pytorch_cos_sim(
                query_embedding, example_task_embedding
                )[0].detach().cpu().numpy()
            idx = np.argsort(cos_scores)[-1]
            most_similar_object, matching_score = corpus[idx], cos_scores[idx]
            return most_similar_object, matching_score

        plan = str_plan.split('\n')
        action_seq = []; cos_score = []
        available_actions = Plan.get_available_actions()
        available_tasks = set(available_actions.keys())
        # match sugoal generated by GPT into ALFRED available subgoals
        for action in plan:
            # Remove empty string
            if action.strip() == '':
                continue
            if ':' in action and not any(temp.isdigit() for temp in action):
                break
            action = re.sub(r"[0-9]", "", action).strip('. ').lower()
            most_similar_task, score = closest_object_roberta(action.lower())
            action_seq.append(available_actions[most_similar_task])
            cos_score.append(float(score))
        # Remove repititive subgoals
        temp = []
        for i, action in enumerate(action_seq):
            if i != 0 and action == action_seq[i-1]:
                continue
            temp.append(action)
        action_seq = temp
        return Plan(high_desc=goal, low_desc=steps, triplets=action_seq), cos_score

    @classmethod
    def from_traj(cls, traj_data:dict, r_idx=None):
        """Generate Plan from trajectory data"""
        if 'ann' in traj_data:
            r_idx = traj_data['ann']['repeat_idx']
        alfred_obj_lower_to_id = dict(zip(constants.OBJECTS_SINGULAR ,constants.OBJECTS))

        triplets = []
        low_actions = []

        for action_chunk in traj_data['plan']['high_pddl']:
            if action_chunk['discrete_action']['action'] in ['GotoLocation', 'NoOp']:
                continue
            h_idx = action_chunk['high_idx']
            action = action_chunk['discrete_action']['action']

            target = action_chunk['planner_action']['coordinateObjectId'][0] \
                if 'coordinateObjectId' in action_chunk['planner_action'] else ''
            recep = action_chunk['planner_action']['coordinateReceptacleObjectId'][0] \
                if 'coordinateReceptacleObjectId' in action_chunk['planner_action'] else ''
            
            if target == '':
                if action_chunk['discrete_action']['args'][0] != '':
                    target = alfred_obj_lower_to_id[action_chunk['discrete_action']['args'][0]]
                else:
                    target = triplets[-1][1]
            if target == '':
                raise Exception('Target not determined')
                
            if recep == '':
                object_id = action_chunk['planner_action']['objectId']
                object_id = '|'.join(object_id.split('|')[:3])
                for _action_chunk in traj_data['plan']['high_pddl']:
                    if _action_chunk['planner_action']['action'] in cls.NAV_ACTIONS | set(['GotoLocation', 'End']):
                        continue
                    _id = '|'.join(_action_chunk['planner_action']['objectId'].split('|')[:4])
                    if _id == object_id\
                        and 'coordinateReceptacleObjectId' in _action_chunk['planner_action'] \
                            and _action_chunk['planner_action']['action'] == 'PickupObject':
                        recep = _action_chunk['planner_action']['coordinateReceptacleObjectId'][0]
                        if h_idx < _action_chunk['high_idx']:
                            break
            low_action = []
            for low_chunk in traj_data['plan']['low_actions']:
                if low_chunk['high_idx'] > h_idx:
                    break
                if low_chunk['high_idx'] < h_idx:
                    continue
                if low_chunk['api_action']['action'] in Plan.NAV_ACTIONS:
                    continue
                low_action.append((
                    low_chunk['api_action']['action'],
                    low_chunk['api_action']['objectId'].split('|')[0]))

            triplets.append([action, target, recep])
            low_actions.append(low_action)

        goal = traj_data['turk_annotations']['anns'][r_idx]['task_desc']
        steps = '\n'.join(traj_data['turk_annotations']['anns'][r_idx]['high_descs'])
        return Plan(high_desc=goal, low_desc=steps, triplets=triplets, low_actions=low_actions)

    @classmethod
    def preprocess_goal(cls, s):
        """Preprocess goal"""
        # remove escape sequence
        s = s.strip()
        if "\n" in s:
            s = s.split("\n")[0]
        if "\b" in s:
            s = s.strip("\b")
        s = s.strip()
        if not any(_s.isupper() for _s in s):
            # lower
            return s.lower()
        # CounterTop -> Counter Top
        capitals = re.findall('[A-Z][^A-Z]*', s)
        processed = []
        left = s.split(capitals[0])[0]
        for _l in capitals:
            if len(_l) == 1:
                left += _l
            else:
                _l = left+_l
                processed.extend(_l.split())
        if len(processed) == 0:
            processed = left.split()
        # lower
        return ' '.join(processed).lower().replace('.', '')
        
    def refine_plan(self):
        triplets = self.high_actions
        for i, triplet in enumerate(triplets):
            if triplet[2] == '':
                if triplet[0] == 'SliceObject':
                    target_found = False
                    for k in triplets[i:]:
                        if k[0] == 'PickupObject' and k[1] == triplet[1] and k[2] != '':
                            triplet[2] = k[2]
                            target_found = True
                            break
                    if not target_found:
                        for k in triplets[i-1::-1]:
                            if k[0] == 'PutObject' and k[1] == triplet[1]:
                                triplet[2] = k[2]
                                target_found = True
                                break
            triplets[i] = triplet
        self.high_actions = triplets

    def get_final_state(self) -> list:
        """Return result alfred objs after executing plan"""
        in_hand = None
        seen_objs = []
        for action in self.high_actions:
            if action[0] == 'PickupObject':
                assert in_hand is None
                # If command Pickup obj in seen objs
                temp = seen_objs
                for _obj in seen_objs:
                    if _obj.name == action[1] \
                        and (_obj.recep == action[2] or (_obj.recep is None and action[2] == '')):
                        in_hand = _obj
                        temp.remove(_obj)
                seen_objs = temp
                # else
                if in_hand is None:
                    in_hand = AlfredObject(action[1])
                # picked up obj has no recep info now
                in_hand.put(None)
            elif action[0] == 'SliceObject':
                assert 'knife' in in_hand.name.lower()
                obj = AlfredObject(action[1], recep=action[2])
                obj.slice()
                seen_objs.append(obj)
            elif action[0] == 'PutObject':
                assert action[1] == in_hand.name
                in_hand.put(action[2])
                seen_objs.append(in_hand)
                in_hand = None
            elif action[0] == 'ToggleObject':
                if in_hand is not None:
                    in_hand.examine()
            elif action[0] == 'HeatObject':
                assert action[1] == in_hand.name or action[1] == ""
                in_hand.heat()
            elif action[0] == 'CoolObject':
                if action[1] == in_hand.name:
                    in_hand.cool()
                elif any([o.recep == 'Fridge' for o in seen_objs]):
                    for _obj in seen_objs:
                        if _obj.recep == 'Fridge':
                            _obj.cool()
                else:
                    raise Exception('Cool object not specified')
            elif action[0] == 'CleanObject':
                assert action[1] == in_hand.name or action[1] == ""
                in_hand.wash()
            else:
                raise Exception('Action not defined')

        if in_hand is not None:
            seen_objs.append(in_hand)

        return seen_objs

    def __eq__(self, other_plan):
        if not self.is_executable() or not other_plan.is_executable():
            raise Exception('One of given plans is not executable')

        objs1 = self.get_final_state()
        objs2 = other_plan.get_final_state()
        only_in_1 = objs1.copy()
        only_in_2 = objs2.copy()

        if any([o.sliced for o in objs1]):
            # If slice task, don't matter type of knife or where knife is
            if not any([o.sliced for o in objs2]):
                return False
            for obj1 in objs1:
                if 'knife' in obj1.name.lower():
                    only_in_1.remove(obj1)
                    for obj2 in objs2:
                        if 'knife' in obj2.name.lower():
                            only_in_2.remove(obj2)
                            break
                else:
                    for obj2 in objs2:
                        if obj1 == obj2:
                            only_in_1.remove(obj1)
                            only_in_2.remove(obj2)
        elif any([o.in_light for o in objs1]):
            if not any([o.in_light for o in objs2]):
                return False
            for obj1 in objs1:
                if 'lamp' in obj1.name.lower():
                    only_in_1.remove(obj1)
                    for obj2 in objs2:
                        if 'lamp' in obj2.name.lower():
                            only_in_2.remove(obj2)
                            break
                else:
                    for obj2 in objs2:
                        if obj1 == obj2:
                            only_in_1.remove(obj1)
                            only_in_2.remove(obj2)
        else:
            for obj_in_1 in objs1:
                for obj_in_2 in objs2:
                    if obj_in_1 == obj_in_2:
                        only_in_1.remove(obj_in_1)
                        only_in_2.remove(obj_in_2)
        return len(only_in_1) == 0 and len(only_in_2) == 0

    def __str__(self):
        desc = ""
        for i, action in enumerate(self.high_actions):
            desc += f"{i+1}. {action[0].replace('Object', ''):8s} {action[1]} {action[2]}\n"
        return desc

    def is_executable(self) -> bool:
        """Check if plan is executable"""
        try:
            self.get_final_state()
            return True
        except:
            return False

    def is_plan_fulfilled(self, task_type:str, params:dict) -> bool:
        """Check if the plan fulfilled task requirement"""
        if not self.is_executable():
            raise Exception('This plan is not executable')
        seen_objs = self.get_final_state()
        mrecep, target = [], []
        for _obj in seen_objs:
            if _obj.name == params['mrecep_target']:
                mrecep.append(_obj)
            if _obj.name == params['object_target']:
                target.append(_obj)

        if params['object_sliced'] and not any([t.sliced for t in target]):
            return False
        if task_type == 'pick_and_place_simple'\
            and not any([t.recep == params['parent_target'] for t in target]):
            return False
        if task_type == 'pick_two_obj_and_place'\
            and not len([t.recep == params['parent_target'] for t in target]) > 1:
            return False
        if task_type == 'look_at_obj_in_light'\
            and not any([t.in_light for t in target]):
            return False
        if task_type == 'pick_clean_then_place_in_recep'\
            and not any([t.clean for t in target])\
                and not any([t.recep == params['parent_target'] for t in target]):
            return False
        if task_type == 'pick_heat_then_place_in_recep'\
            and not any([t.hot for t in target])\
                and not any([t.recep == params['parent_target'] for t in target]):
            return False
        if task_type == 'pick_cool_then_place_in_recep'\
            and not any([t.cold for t in target])\
                and not any([t.recep == params['parent_target'] for t in target]):
            return False
        if task_type == 'pick_and_place_with_movable_recep'\
            and not any([m.recep == params['parent_target'] for m in mrecep])\
                and not any([t.recep == params['mrecep_target'] for t in target]):
            return False
        return True

class AlfredObject:
    """Object in alfred saving status information"""
    receptacles = constants.RECEPTACLES
    val_recep_objects = constants.VAL_RECEPTACLE_OBJECTS
    val_action_objects = constants.VAL_ACTION_OBJECTS
    non_recep_objects = constants.NON_RECEPTACLES_SET

    def __init__(self, name, recep=None):
        self.sliced, self.clean, self.hot, self.cold, self.in_light \
            = False, False, False, False, False
        assert name in AlfredObject.non_recep_objects
        self.name = name
        assert recep in AlfredObject.receptacles or recep is None or recep == '' or recep == '0'
        if recep == '':
            self.recep = None
        else:
            self.recep = recep

    def __str__(self):
        desc = f"{self.name:10s}:\n"
        if self.sliced:
            desc += f" * {'sliced':8s}\n"
        if self.clean:
            desc += f" * {'clean':8s}\n"
        if self.hot:
            desc += f" * {'hot':8s}\n"
        if self.cold:
            desc += f" * {'cold':8s}\n"
        if self.in_light:
            desc += f" * {'in light':8s}\n"
        if self.recep is not None:
            desc += f"   in {self.recep:8s}"
        else:
            desc += f"   in hand"
        return desc

    def __eq__(self, other):
        if not isinstance(other, AlfredObject):
            return False
        return (self.name, self.recep, self.sliced, \
            self.clean, self.hot, self.cold, self.in_light)\
            == (other.name, other.recep, other.sliced, \
                other.clean, other.hot, other.cold, other.in_light)

    def wash(self):
        assert self.name in AlfredObject.val_action_objects['Cleanable']
        self.clean = True

    def heat(self):
        assert self.name in AlfredObject.val_action_objects['Heatable']
        self.hot = True

    def cool(self):
        assert self.name in AlfredObject.val_action_objects['Coolable']
        self.cold = True

    def examine(self):
        assert self.name in AlfredObject.non_recep_objects
        self.in_light = True

    def put(self, recep):
        assert recep in AlfredObject.receptacles or recep is None
        self.recep = recep

    def slice(self):
        assert self.name in AlfredObject.val_action_objects['Sliceable']
        self.sliced = True
